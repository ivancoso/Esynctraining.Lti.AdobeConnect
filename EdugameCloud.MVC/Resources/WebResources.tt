<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<# // To debug, uncomment the next two lines !! 
 //System.Diagnostics.Debugger.Launch();
 //System.Diagnostics.Debugger.Break();
#>
<#PrepareDataToRender(this); #>

<#var manager = Manager.Create(Host, GenerationEnvironment); #>
<#manager.StartHeader(); #>
// <auto-generated />
// This file was generated by a T4 template.
// Don't change it directly as your change would get overwritten.  Instead, make changes
// to the .tt file (i.e. the T4 template) and save it to regenerate this file.

// Make sure the compiler doesn't complain about missing Xml comments
#pragma warning disable 1591
#region T4

namespace EdugameCloud.MVC.Resources {
using System.Diagnostics;
using System.CodeDom.Compiler;
using Esynctraining.Core.Providers;
using Esynctraining.Core.Utils;
<#manager.EndBlock(); #>

	[<#= GeneratedCode #>, DebuggerNonUserCode]
	public static class WebResources
	{
	   private static IResourceProvider ResourceProvider 
	   {
	      get 
		  {   
		      return LazyNested.Instance;
		  }
       }
		  
	 <#foreach (var resource in ResourceInfos) { #>

		public static class <#=resource.Name#> 
	    { <#foreach (var property in resource.Properties) { #>

			public static string <#=property#> 
		    {
			   get 
			   {
			       return ResourceProvider.GetResourceString("<#=property#>", "<#=resource.Name#>");
			   }
		    }
		<#} #>}
	 <#} #>

	   private static class LazyNested
       {
			// Explicit static constructor to tell C# compiler
			// not to mark type as beforefieldinit
			static LazyNested()
			{
			}

			internal static readonly IResourceProvider Instance = IoC.Resolve<IResourceProvider>();
       }
	   
	}

}


#endregion
#pragma warning restore 1591

<#+ 
static string GeneratedCode = @"GeneratedCode(""T4MVC"", ""2.0"")";
static DTE Dte; 
static Project Project;
static Project ResourceProject;
static TextTransformation TT;
static string T4FileName;
static string T4Folder;
static IList<ResourceInfo> ResourceInfos = new List<ResourceInfo>();

internal class ResourceInfo {

   public ResourceInfo()
   {
      Properties = new List<string>();
   }

   public string Name { get;set; }
   public IList<string> Properties { get;set; }
}

void ProcessResourceRecursive(ProjectItem projectItem) {

    // Recurse into all the sub-items (both files and folder can have some - e.g. .tt files)
    foreach (ProjectItem item in projectItem.ProjectItems) {
        ProcessResourceRecursive(item);
    }

    if (projectItem.FileCodeModel != null) {
        foreach (var type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>()) {
            ProcessResourceType(type);
        }
        // Process all the elements that are namespaces
        foreach (var ns in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()) {
            foreach (var type in ns.Members.OfType<CodeClass2>()) {
                ProcessResourceType(type);
            }
        }
    }
}

void ProcessResourceType(CodeClass2 type) {
    if (!IsResource(type))
        return;
	if (type.IsGeneric)
        return;
  var resourceNames = ResourceInfos.Select(x=>x.Name);
  if (resourceNames.Contains(type.Name))
      return;
	var res = new ResourceInfo();
	res.Name = type.Name;
	foreach (CodeElement e in GetProperties(type))
	{
	    if (e.Name == "Culture" || e.Name == "ResourceManager")
		    continue;
		res.Properties.Add(e.Name);
	}
  
	  ResourceInfos.Add(res);
}


  IEnumerable<CodeElement> GetProperties(CodeClass2 codeClass)
  {
   foreach (CodeElement e in GetAllMembers(codeClass))
    if (e.Kind == vsCMElement.vsCMElementProperty)
     yield return e;
  }

  IEnumerable<CodeElement> GetAllMembers(CodeClass2 classe)
  {
   if (classe.ClassKind == vsCMClassKind.vsCMClassKindPartialClass)
   {
    foreach (CodeClass2 partial in classe.PartialClasses)
     foreach (CodeElement member in partial.Members)
      yield return member;
   }
   else
    foreach (CodeElement member in classe.Members)
     yield return member;
  }

bool IsResource(CodeClass2 type) 
{
   return type.Namespace.Name.EndsWith("Resources");
}

void PrepareDataToRender(TextTransformation tt) {
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("T4MVC can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

    if (Project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

    // Get the path of the root folder of the app
    ResourceProject = GetResourceProject(Dte);
	// Get area Controllers folder
    ProjectItem resourceProjectItem = GetProjectItem(ResourceProject.ProjectItems, "App_GlobalResources");
	  ProcessResourceRecursive(resourceProjectItem);
}

ProjectItem GetProjectItem(ProjectItems items, string subPath) {

    ProjectItem current = null;
    foreach (string name in subPath.Split('\\')) {
        try {
            // ProjectItems.Item() throws when it doesn't exist, so catch the exception
            // to return null instead.
            current = items.Item(name);
        }
        catch {
            // If any chunk couldn't be found, fail
            return null;
        }
        items = current.ProjectItems;
    }

    return current;
}

Project GetResourceProject(DTE dte) {
    var projects = Projects(dte);

    foreach (Project proj in projects)
    {
        if (proj.Name == "EdugameCloud.Web")
        {
            return proj;
        }
    }
    
    return null;
}

public static IList<Project> Projects(DTE dte)
{
    Projects projects = dte.Solution.Projects;
    List<Project> list = new List<Project>();
    var item = projects.GetEnumerator();

    while (item.MoveNext())
    {
        var project = item.Current as Project;
        if (project == null)
        {
            continue;
        }

        if (project.Kind == ProjectKinds.vsProjectKindSolutionFolder)
        {
            list.AddRange(GetSolutionFolderProjects(project));
        }
        else
        {
            list.Add(project);
        }
    }

    return list;
}

private static IEnumerable<Project> GetSolutionFolderProjects(Project solutionFolder)
{
    List<Project> list = new List<Project>();
    for (var i = 1; i <= solutionFolder.ProjectItems.Count; i++)
    {
        var subProject = solutionFolder.ProjectItems.Item(i).SubProject;
        if (subProject == null)
        {
            continue;
        }

        // If this is another solution folder, do a recursive call, otherwise add
        if (subProject.Kind == ProjectKinds.vsProjectKindSolutionFolder)
        {
            list.AddRange(GetSolutionFolderProjects(subProject));
        }
        else
        {
            list.Add(subProject);
        }
    }

    return list;
}

Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    return projectItem.ContainingProject;
}

/*
    Manager.tt from Damien Guard: http://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
*/


// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
    }

    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();

    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }

    public void KeepGeneratedFile(String name) {
        name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
        generatedFileNames.Add(name);
    }
    
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }

    public void StartFooter() {
        CurrentBlock = footer;
    }

    public void StartHeader() {
        CurrentBlock = header;
    }

    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }

    public virtual void Process(bool split) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            foreach (Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
        }
    }

    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }

    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }

    public virtual String DefaultProjectNamespace {
        get { return null; }
    }

    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }

    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }

    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }

    private class VSManager : Manager {
        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;

        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }

        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }

        public override void Process(bool split) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split);
            projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }

        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }

        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider)host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }

        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);

            // Remove unused items from the project
            foreach (var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();

            // Add missing files to the project
            foreach (String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }

        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
}

/*
    End of Manager.tt
*/

#>
